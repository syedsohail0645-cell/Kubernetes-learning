1ï¸âƒ£ What is an API in Kubernetes?

Kubernetes exposes everything via an API server (kube-apiserver).

All objects (Pods, Deployments, Services, etc.) are resources exposed through RESTful APIs.

Example:

GET /api/v1/pods
POST /apis/apps/v1/deployments


Here, /api or /apis is the API group and version.

2ï¸âƒ£ What is API Versioning?

API versioning allows Kubernetes to evolve its API without breaking existing clients.

Common versions:

v1 â†’ stable

v1beta1 â†’ beta features, may change

v1alpha1 â†’ alpha features, may be removed

Versioning ensures backward compatibility.

Why do we need versioning?

Imagine:

Kubernetes adds new features to Deployment (like strategy: RollingUpdate).

If older clusters or clients rely on the old behavior, versioning ensures they donâ€™t break.

We can safely upgrade APIs gradually.

3ï¸âƒ£ What are API Groups?

Kubernetes has many APIs, grouped logically.

API groups categorize related resources and allow independent evolution.

Structure:
/api/<version>        â†’ Core API group (no name)
 /api/v1               â†’ Core resources like Pod, Service, Node

/apis/<group>/<version> â†’ Named API groups
 /apis/apps/v1         â†’ Apps resources like Deployment, StatefulSet
 /apis/batch/v1        â†’ Jobs, CronJobs
 /apis/networking.k8s.io/v1 â†’ NetworkPolicies, Ingress

4ï¸âƒ£ Core API Group vs Named API Group
Type	Path	Example Resources	Notes
Core API Group	/api/v1	Pod, Service, Node, ConfigMap	Oldest group, no group name.
Named API Group	/apis/<group>/<version>	Deployment (apps/v1), CronJob (batch/v1), NetworkPolicy (networking.k8s.io/v1)	Allows independent versioning.
5ï¸âƒ£ Why do we use API groups?

Logical grouping of resources

Example: apps group for workloads, networking.k8s.io for networking.

Independent versioning

You can upgrade apps/v1beta1 â†’ apps/v1 without affecting batch/v1.

Extensibility

You can add new API groups for CRDs (CustomResourceDefinition) without touching core APIs.

Stability & compatibility

Alpha â†’ Beta â†’ Stable progression allows safe adoption.

6ï¸âƒ£ API Versioning strategy

Alpha: v1alpha1

May be buggy, can be removed in future releases.

Beta: v1beta1

Feature is mostly stable, may have small changes.

Stable: v1

Guaranteed backward compatibility.

Example: Deployment evolution

Kubernetes 1.2 â†’ extensions/v1beta1 Deployment

Kubernetes 1.9 â†’ apps/v1 Deployment (stable)

7ï¸âƒ£ How to check API groups in your cluster
kubectl api-resources


Example output:

NAME            SHORTNAMES   APIGROUP           NAMESPACED   KIND
pods            po           <none>             true         Pod
deployments     deploy       apps               true         Deployment
jobs            job          batch              true         Job
networkpolicies netpol       networking.k8s.io  true         NetworkPolicy


APIGROUP column shows which API group a resource belongs to.

<none> means Core API group.

8ï¸âƒ£ Visual analogy

Think of Kubernetes APIs like a library:

Core API group â†’ Old classic books (always there).

Named API groups â†’ New sections (Science, Art, Networking).

Versioning â†’ Editions of books (alpha, beta, stable) so you know which is reliable.

9ï¸âƒ£ Key takeaway

API groups â†’ categorize resources logically and allow independent evolution.

API versioning â†’ lets Kubernetes safely evolve features.

Together, they allow stable, scalable, backward-compatible APIs.



ğŸ§  Big Picture Diagram (API Server View)
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚     kube-apiserver         â”‚
                    â”‚  (Single Entry Point)      â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚                                           â”‚
      Core API Group                               Named API Groups
      (no group name)                              (grouped APIs)
            â”‚                                           â”‚
        /api/v1                                   /apis/<group>/<version>
            â”‚                                           â”‚
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚                 â”‚          â”‚              â”‚               â”‚              â”‚
 Pods             Services     apps/v1       batch/v1   networking.k8s.io/v1  rbac.authorization.k8s.io/v1
   â”‚                 â”‚          â”‚              â”‚               â”‚              â”‚
 Pod               Service   Deployment       Job        NetworkPolicy        Role
 Node              ConfigMap StatefulSet     CronJob    Ingress               RoleBinding
 Namespace          Secret   DaemonSet

ğŸ” Zoom-In: Request Flow Example
When you run:
kubectl get pods

kubectl
   â”‚
   â–¼
GET /api/v1/pods
   â”‚
   â–¼
kube-apiserver
   â”‚
   â–¼
Core API Group â†’ v1 â†’ Pod resource

When you run:
kubectl get deployments

kubectl
   â”‚
   â–¼
GET /apis/apps/v1/deployments
   â”‚
   â–¼
kube-apiserver
   â”‚
   â–¼
Named API Group â†’ apps â†’ v1 â†’ Deployment

ğŸ§© Why Kubernetes Designed It This Way (Diagram Logic)
Problem:
âŒ One huge API â†’ hard to change â†’ breaks old clients

Solution:
âœ… Split APIs into groups
âœ… Version each group independently

apps/v1        â†’ stable workloads
batch/v1      â†’ jobs & cronjobs
networking/*  â†’ networking features
rbac/*        â†’ security & auth


â¡ Each team in Kubernetes can evolve their API group independently.

ğŸ—ï¸ Version Lifecycle Diagram
v1alpha1  â”€â”€â”€â–º  v1beta1  â”€â”€â”€â–º  v1
(unsafe)       (mostly ok)    (stable)


Example:

extensions/v1beta1 Deployment  âŒ (deprecated)
apps/v1 Deployment             âœ… (stable)

ğŸ§  One-Line Interview Memory Trick

â€œAPI groups organize Kubernetes resources, and API versions allow those groups to evolve safely without breaking existing clusters.â€

ğŸ¯ Super-Important Interview Points (Remember These)

Core API group has no name (/api/v1)

Named API groups use /apis/<group>/<version>

Versioning prevents breaking changes

CRDs also create custom API groups

kube-apiserver routes requests using group + version


Here you go â€” crisp, interview-perfect (2â€“3 lines) âœ…

API groups logically organize Kubernetes resources and allow different parts of the API to evolve independently.
API versioning (alpha, beta, stable) ensures backward compatibility while safely introducing new features.
Together, they make Kubernetes extensible, scalable, and upgrade-safe without breaking existing workloads.
